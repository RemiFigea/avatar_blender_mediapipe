from flask import Flask, redirect, render_template, request, url_for
from flask_socketio import SocketIO
from multiprocessing import Process, Queue
import os
from scripts.generate_landmarks import generate_landmarks_file
from scripts.process_managing import stop_landmarks_generation_if_running, stop_video_generation_if_running
from scripts.utils import is_valid_video_file, save_uploaded_file
import subprocess

PATHS_DICT = {
    'blender_executable': './opt/blender/blender',
    'blender_script': './scripts/generate_video.py',
    'generated_video': './static/generated_video.mp4',
    'input_dir': './input',
    'landmarks': './static/landmarks.json',
    'original_model': './data/original_model.blend',
}

ALLOWED_EXTENSIONS = {'mp4', 'avi', 'mov', 'mkv', 'webm'}

app = Flask(__name__)
#app.config['SECRET_KEY'] = os.urandom(24)
socketio =  SocketIO(app, cors_allowed_origins='*', async_mode='threading')

app.config['INPUT_DIRPATH'] = PATHS_DICT.get('input_dir')
app.config['APPLICATION_ROOT'] = '/'
app.config['PREFERRED_URL_SCHEME'] = 'http'

process_queue = Queue()
landmark_process = None
video_process = None
generated_video_name = os.path.basename(PATHS_DICT.get('generated_video'))


# Transmit from blender script to client
@socketio.on('message')
def handle_message(message):
    socketio.emit('message', message)

@app.route('/')
def index():
    '''
    Render the video template with the video generated by Blender.
    '''
    return render_template('animation.html', video_name=generated_video_name)

@app.route('/upload_video', methods=['POST'])
def upload_video():
    '''
    Handles video file upload, validates the file, execute the landmarks and video generation process and redirects to index page.
    '''
    global landmark_process, video_process

    if not is_valid_video_file(request, ALLOWED_EXTENSIONS, socketio):
        return redirect(url_for('index'))
    
    uploaded_video_file = request.files['video_file']
    uploaded_video_filepath = save_uploaded_file(uploaded_video_file, PATHS_DICT.get('input_dir'))
  
    stop_landmarks_generation_if_running(landmark_process, socketio)
    stop_video_generation_if_running(video_process, socketio)
 
    try: 
        socketio.emit('message', 'Generating landmarks...')
        landmark_process = Process(
            target=generate_landmarks_file,
            args=(uploaded_video_filepath, PATHS_DICT.get('landmarks'), process_queue, )
            )
        landmark_process.start()
        landmark_process.join()
    except:
        socketio.emit('message', 'Landamrks generation failed.')
        return redirect(url_for('index'))

    if not process_queue.empty():
        result = process_queue.get()
        socketio.emit('message', result)

        if result == 'Landmarks generation terminated successfully.':
            command = [
                PATHS_DICT.get('blender_executable'),
                '-b',
                '--python', PATHS_DICT.get('blender_script'),
                '--',
                PATHS_DICT.get('landmarks'),
                PATHS_DICT.get('original_model'),
                PATHS_DICT.get('generated_video')
            ]
            socketio.emit('message', 'Starting video generation...')

            try:
                video_process = subprocess.Popen(command)
                video_process.wait()
            except:
                socketio.emit('message', 'Video generation failed.')
      
    return redirect(url_for('index'))

if __name__ == "__main__":
    socketio.run(app, debug=True, host="0.0.0.0", port=5000, allow_unsafe_werkzeug=True)